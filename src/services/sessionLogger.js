import { supabase } from '../lib/supabase';

export class SessionLogger {
  static logBuffer = new Map();
  static flushInterval = null;

  /**
   * Initialize session logger
   */
  static initialize() {
    try {
      // Start periodic flush of logs
      this.flushInterval = setInterval(() => {
        this.flushLogs();
      }, 30000); // Flush every 30 seconds

      console.log('Session Logger initialized');
      return { success: true };
    } catch (error) {
      console.error('Error initializing session logger:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log session start
   */
  static async logSessionStart(sessionData) {
    try {
      const logEntry = {
        session_id: sessionData.sessionId,
        session_type: sessionData.type, // 'call' or 'chat'
        user_id: sessionData.userId,
        reader_id: sessionData.readerId,
        booking_id: sessionData.bookingId,
        event_type: 'session_start',
        event_data: {
          timestamp: new Date().toISOString(),
          session_details: sessionData
        },
        ai_tag: 'safe',
        risk_score: 0
      };

      await this.addToBuffer(logEntry);
      return { success: true };
    } catch (error) {
      console.error('Error logging session start:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log AI analysis result
   */
  static async logAIAnalysis(sessionId, analysisData) {
    try {
      const logEntry = {
        session_id: sessionId,
        event_type: 'ai_analysis',
        event_data: {
          timestamp: new Date().toISOString(),
          analysis_result: analysisData,
          violations: analysisData.violations || [],
          emotions: analysisData.emotions || {},
          patterns: analysisData.patterns || []
        },
        ai_tag: analysisData.sessionTag || 'safe',
        risk_score: analysisData.riskScore || 0
      };

      await this.addToBuffer(logEntry);
      return { success: true };
    } catch (error) {
      console.error('Error logging AI analysis:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log escalation event
   */
  static async logEscalation(sessionId, escalationData) {
    try {
      const logEntry = {
        session_id: sessionId,
        event_type: 'escalation',
        event_data: {
          timestamp: new Date().toISOString(),
          escalation_level: escalationData.level,
          actions_taken: escalationData.actions,
          reason: escalationData.reason,
          auto_generated: escalationData.autoGenerated || false
        },
        ai_tag: 'critical',
        risk_score: escalationData.riskScore || 100
      };

      await this.addToBuffer(logEntry);
      
      // Also log to escalation table immediately for critical events
      if (escalationData.level === 'critical') {
        await this.logCriticalEscalation(sessionId, escalationData);
      }

      return { success: true };
    } catch (error) {
      console.error('Error logging escalation:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log human intervention
   */
  static async logHumanIntervention(sessionId, interventionData) {
    try {
      const logEntry = {
        session_id: sessionId,
        event_type: 'human_intervention',
        event_data: {
          timestamp: new Date().toISOString(),
          monitor_id: interventionData.monitorId,
          action_taken: interventionData.action,
          reason: interventionData.reason,
          notes: interventionData.notes
        },
        ai_tag: 'reviewed',
        risk_score: interventionData.riskScore || 0
      };

      await this.addToBuffer(logEntry);
      return { success: true };
    } catch (error) {
      console.error('Error logging human intervention:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log session end
   */
  static async logSessionEnd(sessionId, endData) {
    try {
      const logEntry = {
        session_id: sessionId,
        event_type: 'session_end',
        event_data: {
          timestamp: new Date().toISOString(),
          duration: endData.duration,
          end_reason: endData.reason,
          final_tag: endData.finalTag,
          total_violations: endData.totalViolations || 0,
          human_reviewed: endData.humanReviewed || false
        },
        ai_tag: endData.finalTag || 'safe',
        risk_score: endData.finalRiskScore || 0
      };

      await this.addToBuffer(logEntry);
      
      // Force flush for session end
      await this.flushLogs();
      
      return { success: true };
    } catch (error) {
      console.error('Error logging session end:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log AI feedback
   */
  static async logAIFeedback(alertId, feedbackData) {
    try {
      const logEntry = {
        alert_id: alertId,
        event_type: 'ai_feedback',
        event_data: {
          timestamp: new Date().toISOString(),
          feedback_type: feedbackData.type, // 'accurate' or 'false_positive'
          reviewer_id: feedbackData.reviewerId,
          notes: feedbackData.notes,
          original_risk_score: feedbackData.originalRiskScore
        },
        ai_tag: 'feedback',
        risk_score: 0
      };

      await this.addToBuffer(logEntry);
      return { success: true };
    } catch (error) {
      console.error('Error logging AI feedback:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Add log entry to buffer
   */
  static async addToBuffer(logEntry) {
    try {
      const bufferId = `${logEntry.session_id || logEntry.alert_id}_${Date.now()}`;
      this.logBuffer.set(bufferId, {
        ...logEntry,
        created_at: new Date().toISOString()
      });

      // If buffer is getting large, flush immediately
      if (this.logBuffer.size > 100) {
        await this.flushLogs();
      }

      return { success: true };
    } catch (error) {
      console.error('Error adding to log buffer:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Flush logs to database
   */
  static async flushLogs() {
    try {
      if (this.logBuffer.size === 0) return;

      const logsToFlush = Array.from(this.logBuffer.values());
      this.logBuffer.clear();

      // Insert logs in batches
      const batchSize = 50;
      for (let i = 0; i < logsToFlush.length; i += batchSize) {
        const batch = logsToFlush.slice(i, i + batchSize);
        
        const { error } = await supabase
          .from('session_logs')
          .insert(batch);

        if (error) {
          console.error('Error flushing logs batch:', error);
          // Re-add failed logs to buffer for retry
          batch.forEach((log, index) => {
            this.logBuffer.set(`retry_${i + index}_${Date.now()}`, log);
          });
        }
      }

      console.log(`Flushed ${logsToFlush.length} log entries`);
      return { success: true };
    } catch (error) {
      console.error('Error flushing logs:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Log critical escalation immediately
   */
  static async logCriticalEscalation(sessionId, escalationData) {
    try {
      const { error } = await supabase
        .from('critical_escalation_logs')
        .insert([{
          session_id: sessionId,
          escalation_level: escalationData.level,
          risk_score: escalationData.riskScore,
          actions_taken: escalationData.actions,
          reason: escalationData.reason,
          auto_generated: escalationData.autoGenerated,
          timestamp: new Date().toISOString()
        }]);

      if (error) throw error;
      return { success: true };
    } catch (error) {
      console.error('Error logging critical escalation:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get session logs
   */
  static async getSessionLogs(sessionId, filters = {}) {
    try {
      let query = supabase
        .from('session_logs')
        .select('*')
        .eq('session_id', sessionId)
        .order('created_at', { ascending: true });

      if (filters.eventType) {
        query = query.eq('event_type', filters.eventType);
      }

      if (filters.aiTag) {
        query = query.eq('ai_tag', filters.aiTag);
      }

      if (filters.minRiskScore) {
        query = query.gte('risk_score', filters.minRiskScore);
      }

      const { data, error } = await query;
      if (error) throw error;

      return {
        success: true,
        data: data || [],
        message: 'Session logs retrieved successfully'
      };
    } catch (error) {
      console.error('Error getting session logs:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to retrieve session logs'
      };
    }
  }

  /**
   * Get audit trail for a user
   */
  static async getUserAuditTrail(userId, filters = {}) {
    try {
      let query = supabase
        .from('session_logs')
        .select('*')
        .or(`user_id.eq.${userId},reader_id.eq.${userId}`)
        .order('created_at', { ascending: false });

      if (filters.limit) {
        query = query.limit(filters.limit);
      }

      if (filters.dateFrom) {
        query = query.gte('created_at', filters.dateFrom);
      }

      if (filters.dateTo) {
        query = query.lte('created_at', filters.dateTo);
      }

      const { data, error } = await query;
      if (error) throw error;

      return {
        success: true,
        data: data || [],
        message: 'User audit trail retrieved successfully'
      };
    } catch (error) {
      console.error('Error getting user audit trail:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to retrieve user audit trail'
      };
    }
  }

  /**
   * Get comprehensive audit report
   */
  static async getAuditReport(filters = {}) {
    try {
      let query = supabase
        .from('session_logs')
        .select('*')
        .order('created_at', { ascending: false });

      if (filters.dateFrom) {
        query = query.gte('created_at', filters.dateFrom);
      }

      if (filters.dateTo) {
        query = query.lte('created_at', filters.dateTo);
      }

      if (filters.eventType) {
        query = query.eq('event_type', filters.eventType);
      }

      if (filters.aiTag) {
        query = query.eq('ai_tag', filters.aiTag);
      }

      if (filters.minRiskScore) {
        query = query.gte('risk_score', filters.minRiskScore);
      }

      if (filters.limit) {
        query = query.limit(filters.limit);
      }

      const { data, error } = await query;
      if (error) throw error;

      // Generate summary statistics
      const summary = this.generateAuditSummary(data);

      return {
        success: true,
        data: {
          logs: data || [],
          summary: summary
        },
        message: 'Audit report generated successfully'
      };
    } catch (error) {
      console.error('Error generating audit report:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to generate audit report'
      };
    }
  }

  /**
   * Generate audit summary statistics
   */
  static generateAuditSummary(logs) {
    try {
      const summary = {
        totalEvents: logs.length,
        eventsByType: {},
        tagDistribution: {},
        riskScoreStats: {
          average: 0,
          max: 0,
          min: 100,
          high: 0 // Count of high risk events (>70)
        },
        timeRange: {
          from: null,
          to: null
        }
      };

      if (logs.length === 0) return summary;

      let totalRiskScore = 0;
      const timestamps = [];

      logs.forEach(log => {
        // Event type distribution
        summary.eventsByType[log.event_type] = (summary.eventsByType[log.event_type] || 0) + 1;

        // Tag distribution
        summary.tagDistribution[log.ai_tag] = (summary.tagDistribution[log.ai_tag] || 0) + 1;

        // Risk score statistics
        const riskScore = log.risk_score || 0;
        totalRiskScore += riskScore;
        summary.riskScoreStats.max = Math.max(summary.riskScoreStats.max, riskScore);
        summary.riskScoreStats.min = Math.min(summary.riskScoreStats.min, riskScore);
        
        if (riskScore > 70) {
          summary.riskScoreStats.high++;
        }

        // Collect timestamps
        timestamps.push(new Date(log.created_at));
      });

      // Calculate average risk score
      summary.riskScoreStats.average = totalRiskScore / logs.length;

      // Time range
      timestamps.sort((a, b) => a - b);
      summary.timeRange.from = timestamps[0];
      summary.timeRange.to = timestamps[timestamps.length - 1];

      return summary;
    } catch (error) {
      console.error('Error generating audit summary:', error);
      return {
        totalEvents: 0,
        eventsByType: {},
        tagDistribution: {},
        riskScoreStats: { average: 0, max: 0, min: 0, high: 0 },
        timeRange: { from: null, to: null }
      };
    }
  }

  /**
   * Clean up old logs (admin only)
   */
  static async cleanupOldLogs(retentionDays = 365) {
    try {
      const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);

      const { error } = await supabase
        .from('session_logs')
        .delete()
        .lt('created_at', cutoffDate.toISOString());

      if (error) throw error;

      console.log(`Cleaned up logs older than ${retentionDays} days`);
      return { success: true };
    } catch (error) {
      console.error('Error cleaning up old logs:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Shutdown logger
   */
  static shutdown() {
    try {
      if (this.flushInterval) {
        clearInterval(this.flushInterval);
        this.flushInterval = null;
      }

      // Final flush
      this.flushLogs();

      console.log('Session Logger shutdown');
      return { success: true };
    } catch (error) {
      console.error('Error shutting down session logger:', error);
      return { success: false, error: error.message };
    }
  }
}

export default SessionLogger; 