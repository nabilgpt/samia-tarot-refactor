import { supabase, authHelpers, profileHelpers, isDevMode } from '../lib/supabase.js';

// =====================================================
// SUPER ADMIN API - MAXIMUM PRIVILEGES
// =====================================================

// Mock data for development mode
const mockSuperAdminData = {
  stats: {
    totalUsers: 156,
    activeUsers: 142,
    totalBookings: 1234,
    revenue: 45678.90,
    systemHealth: 95
  },
  systemHealth: {
    status: 'healthy',
    uptime: '99.9%',
    responseTime: '120ms',
    databaseConnections: 8,
    memoryUsage: '45%',
    diskUsage: '32%'
  },
  users: [
    {
      id: 'c3922fea-329a-4d6e-800c-3e03c9fe341d',
      first_name: 'Mohamad Nabil',
      last_name: 'Zein',
      email: 'info@samiatarot.com',
      role: 'super_admin',
      is_active: true,
      created_at: '2024-01-01T00:00:00Z',
      auth_users: {
        email: 'info@samiatarot.com',
        created_at: '2024-01-01T00:00:00Z',
        last_sign_in_at: new Date().toISOString(),
        email_confirmed_at: '2024-01-01T00:00:00Z'
      }
    },
    {
      id: 'c1a12781-5fef-46df-a1fc-2bf4e4cb6356',
      first_name: 'Nabil',
      last_name: 'GPT',
      email: 'nabilgpt.en@gmail.com',
      role: 'reader',
      is_active: true,
      created_at: '2024-01-02T00:00:00Z',
      auth_users: {
        email: 'nabilgpt.en@gmail.com',
        created_at: '2024-01-02T00:00:00Z',
        last_sign_in_at: '2024-01-15T10:30:00Z',
        email_confirmed_at: '2024-01-02T00:00:00Z'
      }
    }
  ]
};

export class SuperAdminAPI {
  // =====================================================
  // SECURITY & VALIDATION
  // =====================================================

  /**
   * Verify super admin privileges
   */
  static async verifySuperAdmin() {
    try {
      // In development mode, check if user is authenticated and has super_admin role
      if (isDevMode) {
        console.log('🔧 Mock mode: Verifying super admin access...');
        
        // Check if we have an authenticated user from AuthContext
        const authData = JSON.parse(localStorage.getItem('samia-tarot-auth') || '{}');
        if (!authData.user) {
          throw new Error('Authentication required');
        }
        
        // Check role from profile
        const profileData = JSON.parse(localStorage.getItem('samia-tarot-profile') || '{}');
        if (!profileData.role || profileData.role !== 'super_admin') {
          throw new Error('Super Admin privileges required');
        }
        
        console.log('✅ Mock mode: Super admin access verified');
        return { 
          success: true, 
          user: authData.user, 
          profile: profileData 
        };
      }
      
      // Production mode - original logic
      const currentUser = await authHelpers.getCurrentUser();
      if (!currentUser) {
        throw new Error('Authentication required');
      }

      const { data: profile } = await profileHelpers.getProfile(currentUser.id);
      if (!profile || profile.role !== 'super_admin') {
        throw new Error('Super Admin privileges required');
      }

      return { success: true, user: currentUser, profile };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Log super admin action for audit
   */
  static async logAction(action, targetUserId = null, details = {}) {
    try {
      // In development mode, just log to console
      if (isDevMode) {
        console.log('🔧 Mock mode: Super admin action logged:', {
          action,
          targetUserId,
          details,
          timestamp: new Date().toISOString()
        });
        return;
      }
      
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return;

      await supabase
        .from('super_admin_audit_logs')
        .insert({
          super_admin_id: verification.user.id,
          action,
          target_user_id: targetUserId,
          details: JSON.stringify(details),
          timestamp: new Date().toISOString(),
          ip_address: window.location.hostname
        });
    } catch (error) {
      console.error('Failed to log super admin action:', error);
    }
  }

  // =====================================================
  // USER MANAGEMENT - COMPLETE CONTROL
  // =====================================================

  /**
   * Get all users with complete data
   */
  static async getAllUsers(filters = {}) {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning users data');
        
        let mockUsers = [...mockSuperAdminData.users];
        
        // Apply filters to mock data
        if (filters.role) {
          mockUsers = mockUsers.filter(user => user.role === filters.role);
        }
        if (filters.search) {
          const searchLower = filters.search.toLowerCase();
          mockUsers = mockUsers.filter(user => 
            user.first_name?.toLowerCase().includes(searchLower) ||
            user.last_name?.toLowerCase().includes(searchLower) ||
            user.email?.toLowerCase().includes(searchLower)
          );
        }
        
        return { success: true, data: mockUsers };
      }

      // Use the correct foreign key relationship name: profiles_id_fkey
      let query = supabase
        .from('profiles')
        .select(`
          *,
          auth_users(email, created_at, last_sign_in_at, email_confirmed_at)
        `)
        .order('created_at', { ascending: false });

      // Apply filters
      if (filters.role) query = query.eq('role', filters.role);
      if (filters.country) query = query.eq('country', filters.country);
      if (filters.is_active !== undefined && filters.is_active !== '') {
        query = query.eq('is_active', filters.is_active === 'true' || filters.is_active === true);
      }
      if (filters.search) {
        query = query.or(`first_name.ilike.%${filters.search}%,last_name.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
      }

      // Add sorting options
      if (filters.sortBy) {
        const direction = filters.sortOrder === 'asc' ? { ascending: true } : { ascending: false };
        query = query.order(filters.sortBy, direction);
      }

      const { data, error } = await query;
      if (error) throw error;

      await this.logAction('GET_ALL_USERS', null, { filters, count: data?.length });

      return { success: true, data: data || [] };
    } catch (error) {
      console.error('SuperAdmin getAllUsers error:', error);
      
      // Enhanced error handling with specific relationship error detection
      if (error.message?.includes('no matches were found') || 
          error.message?.includes('Could not find a relationship')) {
        
        console.warn('❌ No foreign key relationship found between profiles and auth.users');
        console.warn('📋 SOLUTION: Run the SQL script CREATE_PROFILES_RELATIONSHIP.sql in Supabase Dashboard');
        
        // Try a simpler query without relationships as fallback
        try {
          console.warn('🔄 Falling back to basic profile query without auth data...');
          
          let fallbackQuery = supabase
            .from('profiles')
            .select('*')
            .order('created_at', { ascending: false });

          // Apply same filters to fallback
          if (filters.role) fallbackQuery = fallbackQuery.eq('role', filters.role);
          if (filters.country) fallbackQuery = fallbackQuery.eq('country', filters.country);
          if (filters.is_active !== undefined && filters.is_active !== '') {
            fallbackQuery = fallbackQuery.eq('is_active', filters.is_active === 'true' || filters.is_active === true);
          }
          if (filters.search) {
            fallbackQuery = fallbackQuery.or(`first_name.ilike.%${filters.search}%,last_name.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
          }

          const { data: fallbackData, error: fallbackError } = await fallbackQuery;
          
          if (fallbackError) throw fallbackError;
          
          // Add placeholder auth user data 
          const enhancedData = fallbackData.map(profile => ({
            ...profile,
            auth_users: { 
              email: profile.email || 'No email available',
              created_at: profile.created_at,
              last_sign_in_at: null,
              email_confirmed_at: null
            }
          }));

          return { 
            success: true, 
            data: enhancedData,
            warning: 'No relationship found. Returned basic profile data. Please run CREATE_PROFILES_RELATIONSHIP.sql to fix this.'
          };
        } catch (fallbackError) {
          return { 
            success: false, 
            error: `Relationship missing and fallback failed. Please run CREATE_PROFILES_RELATIONSHIP.sql in Supabase Dashboard to create the required foreign key relationship.`
          };
        }
      }
      
      // Other error fallbacks
      try {
        console.warn('Falling back to basic profile query due to general error');
        
        let fallbackQuery = supabase
          .from('profiles')
          .select('*')
          .order('created_at', { ascending: false });

        // Apply same filters to fallback
        if (filters.role) fallbackQuery = fallbackQuery.eq('role', filters.role);
        if (filters.country) fallbackQuery = fallbackQuery.eq('country', filters.country);
        if (filters.is_active !== undefined && filters.is_active !== '') {
          fallbackQuery = fallbackQuery.eq('is_active', filters.is_active === 'true' || filters.is_active === true);
        }
        if (filters.search) {
          fallbackQuery = fallbackQuery.or(`first_name.ilike.%${filters.search}%,last_name.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
        }

        const { data: fallbackData, error: fallbackError } = await fallbackQuery;
        
        if (fallbackError) throw fallbackError;
        
        // Add minimal auth user data manually
        const enhancedData = fallbackData.map(profile => ({
          ...profile,
          auth_users: { email: profile.email || 'No email' }
        }));

        return { 
          success: true, 
          data: enhancedData,
          warning: `API error but returned cached data: ${error.message}`
        };
      } catch (fallbackError) {
        return { success: false, error: `Primary query failed: ${error.message}. Fallback failed: ${fallbackError.message}` };
      }
    }
  }

  /**
   * Update any user's profile with complete control
   */
  static async updateUserProfile(userId, updates) {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Get current profile for audit
      const { data: currentProfile } = await profileHelpers.getProfile(userId);

      const { data, error } = await supabase
        .from('profiles')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', userId)
        .select()
        .single();

      if (error) throw error;

      await this.logAction('UPDATE_USER_PROFILE', userId, {
        previous: currentProfile,
        updates,
        new_data: data
      });

      return { success: true, data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Delete any user completely
   */
  static async deleteUser(userId, reason = '') {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Get user data for audit before deletion
      const { data: userData } = await profileHelpers.getProfile(userId);

      // Delete from auth.users (cascades to profiles)
      const { error: authError } = await supabase.auth.admin.deleteUser(userId);
      if (authError) throw authError;

      await this.logAction('DELETE_USER', userId, {
        deleted_user: userData,
        reason,
        permanent_deletion: true
      });

      return { success: true, message: 'User deleted permanently' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Impersonate any user account
   */
  static async impersonateUser(userId) {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Store current session for restoration
      const currentSession = await authHelpers.getCurrentSession();
      
      // Create impersonation session
      const { data, error } = await supabase
        .from('impersonation_sessions')
        .insert({
          super_admin_id: verification.user.id,
          target_user_id: userId,
          started_at: new Date().toISOString(),
          original_session_id: currentSession?.session?.id
        })
        .select()
        .single();

      if (error) throw error;

      await this.logAction('START_IMPERSONATION', userId, {
        impersonation_session_id: data.id,
        original_session: currentSession?.session?.id
      });

      return { 
        success: true, 
        data: {
          impersonation_session_id: data.id,
          target_user_id: userId,
          message: 'Impersonation session started'
        }
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * End impersonation and restore original session
   */
  static async endImpersonation(impersonationSessionId) {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      const { data, error } = await supabase
        .from('impersonation_sessions')
        .update({
          ended_at: new Date().toISOString()
        })
        .eq('id', impersonationSessionId)
        .eq('super_admin_id', verification.user.id)
        .select()
        .single();

      if (error) throw error;

      await this.logAction('END_IMPERSONATION', data.target_user_id, {
        impersonation_session_id: impersonationSessionId,
        duration: new Date() - new Date(data.started_at)
      });

      return { success: true, message: 'Impersonation ended' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // =====================================================
  // SYSTEM MANAGEMENT
  // =====================================================

  /**
   * Get all system settings
   */
  static async getSystemSettings() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning system settings data');
        const mockSettings = {
          api_keys: {
            openai_api_key: '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',
            openai_org_id: 'org-86Ph6EJRXApTkzhnBzt32XQw',
            stripe_secret_key: 'sk_test_51O7wlPHrOKYjfN7YyuNtJ5BqGa0cLNnAkQR4SLXF2tqMmIiCuSyHnWRolU8hEodP42qBYS3hlZtQ67I4TxZAdrZv00vWeDcnyO',
            stripe_publishable_key: 'pk_test_51O7wlPHrOKYjfN7YiCTjjpexAQ0GCGFVYZNv9C2krbOjIvGoFuOckSER6gSj12psZOXgjBP2VlmHxpwLwu9s5AwW00qPXZX2Cn',
            stripe_webhook_secret: 'whsec_test_webhook_secret'
          },
          database: {
            connection_pooling: true,
            max_connections: 100,
            query_timeout: 30000,
            backup_enabled: true,
            maintenance_mode: false
          },
          payments: {
            default_currency: 'USD',
            payment_timeout: 900,
            auto_refund_enabled: true,
            stripe_enabled: true,
            paypal_enabled: true
          },
          notifications: {
            email_enabled: true,
            sms_enabled: true,
            push_enabled: true,
            slack_webhook_url: '',
            email_from: 'noreply@samiatarot.com'
          },
          security: {
            session_timeout: 3600,
            max_login_attempts: 5,
            password_min_length: 8,
            two_factor_enabled: false,
            ip_whitelist_enabled: false
          },
          system: {
            maintenance_mode: false,
            debug_mode: true,
            log_level: 'info',
            max_file_upload_size: 10485760,
            timezone: 'UTC'
          }
        };
        
        return { success: true, data: mockSettings };
      }

      const { data, error } = await supabase
        .from('system_settings')
        .select('*')
        .order('category', { ascending: true });

      if (error) throw error;

      // Transform flat array into nested object structure
      const settingsObject = {};
      if (data && data.length > 0) {
        data.forEach(setting => {
          const category = setting.category || 'general';
          if (!settingsObject[category]) {
            settingsObject[category] = {};
          }
          
          // Parse JSON value if it's a string, otherwise use as-is
          let value = setting.value;
          try {
            if (typeof value === 'string') {
              value = JSON.parse(value);
            }
          } catch (e) {
            // If parsing fails, use the raw value
            value = setting.value;
          }
          
          settingsObject[category][setting.key] = value;
        });
      }

      await this.logAction('GET_SYSTEM_SETTINGS');

      return { success: true, data: settingsObject };
    } catch (error) {
      console.error('Error fetching system settings:', error);
      
      // Fallback to mock data if database fails
      if (error.message?.includes('table') || error.message?.includes('Invalid API key')) {
        console.log('🔧 Falling back to mock system settings data');
        const mockSettings = {
          api_keys: {
            openai_api_key: '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',
            openai_org_id: 'org-86Ph6EJRXApTkzhnBzt32XQw',
            stripe_secret_key: 'sk_test_51O7wlPHrOKYjfN7YyuNtJ5BqGa0cLNnAkQR4SLXF2tqMmIiCuSyHnWRolU8hEodP42qBYS3hlZtQ67I4TxZAdrZv00vWeDcnyO',
            stripe_publishable_key: 'pk_test_51O7wlPHrOKYjfN7YiCTjjpexAQ0GCGFVYZNv9C2krbOjIvGoFuOckSER6gSj12psZOXgjBP2VlmHxpwLwu9s5AwW00qPXZX2Cn',
            stripe_webhook_secret: 'whsec_test_webhook_secret'
          },
          system: {
            maintenance_mode: false,
            debug_mode: true,
            log_level: 'info'
          }
        };
        
        return { success: true, data: mockSettings };
      }

      return { success: false, error: error.message };
    }
  }

  /**
   * Update system settings
   */
  static async updateSystemSetting(settingKey, value, category = 'general') {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Use upsert with proper conflict resolution
      const { data, error } = await supabase
        .from('system_settings')
        .upsert({
          key: settingKey,
          value: JSON.stringify(value),
          category,
          updated_by: verification.user.id,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key',
          ignoreDuplicates: false
        })
        .select()
        .single();

      if (error) {
        // If upsert fails due to conflict, try update instead
        if (error.code === 'PGRST116' || error.message?.includes('duplicate') || error.message?.includes('conflict')) {
          const { data: updateData, error: updateError } = await supabase
            .from('system_settings')
            .update({
              value: JSON.stringify(value),
              category,
              updated_by: verification.user.id,
              updated_at: new Date().toISOString()
            })
            .eq('key', settingKey)
            .select()
            .single();

          if (updateError) throw updateError;
          
          await this.logAction('UPDATE_SYSTEM_SETTING', null, {
            setting_key: settingKey,
            new_value: value,
            category,
            method: 'update_fallback'
          });

          return { success: true, data: updateData };
        }
        throw error;
      }

      await this.logAction('UPDATE_SYSTEM_SETTING', null, {
        setting_key: settingKey,
        new_value: value,
        category,
        method: 'upsert'
      });

      return { success: true, data };
    } catch (error) {
      console.error('System setting update error:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get complete database statistics
   */
  static async getDatabaseStats() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning database stats');
        return { success: true, data: mockSuperAdminData.stats };
      }

      const tables = [
        'profiles', 'services', 'bookings', 'payments', 'messages', 
        'reviews', 'notifications', 'wallets', 'transactions',
        'call_sessions', 'call_recordings', 'emergency_call_logs'
      ];

      const stats = {};
      
      for (const table of tables) {
        try {
          const { count, error } = await supabase
            .from(table)
            .select('*', { count: 'exact', head: true });
          
          if (error) throw error;
          stats[table] = count || 0;
        } catch (err) {
          stats[table] = 'Error';
        }
      }

      await this.logAction('GET_DATABASE_STATS');

      return { success: true, data: stats };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // =====================================================
  // REAL-TIME CONTROLS
  // =====================================================

  /**
   * Get all active sessions
   */
  static async getActiveSessions() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      const { data, error } = await supabase
        .from('bookings')
        .select(`
          *,
          service:services(*),
          client:profiles!bookings_user_id_fkey(*),
          reader:profiles!bookings_reader_id_fkey(*),
          messages:messages(*),
          call_session:call_sessions(*)
        `)
        .eq('status', 'in_progress')
        .order('scheduled_at', { ascending: true });

      if (error) throw error;

      await this.logAction('GET_ACTIVE_SESSIONS');

      return { success: true, data: data || [] };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Force end any session
   */
  static async forceEndSession(bookingId, reason = '') {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      const { data, error } = await supabase
        .from('bookings')
        .update({
          status: 'force_ended',
          ended_at: new Date().toISOString(),
          admin_notes: `Force ended by super admin: ${reason}`
        })
        .eq('id', bookingId)
        .select()
        .single();

      if (error) throw error;

      await this.logAction('FORCE_END_SESSION', null, {
        booking_id: bookingId,
        reason,
        session_data: data
      });

      return { success: true, data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Override booking assignment
   */
  static async reassignBooking(bookingId, newReaderId, reason = '') {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      const { data: currentBooking } = await supabase
        .from('bookings')
        .select('*')
        .eq('id', bookingId)
        .single();

      const { data, error } = await supabase
        .from('bookings')
        .update({
          reader_id: newReaderId,
          admin_notes: `Reassigned by super admin: ${reason}`,
          updated_at: new Date().toISOString()
        })
        .eq('id', bookingId)
        .select()
        .single();

      if (error) throw error;

      await this.logAction('REASSIGN_BOOKING', null, {
        booking_id: bookingId,
        previous_reader_id: currentBooking?.reader_id,
        new_reader_id: newReaderId,
        reason
      });

      return { success: true, data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // =====================================================
  // AUDIT & MONITORING
  // =====================================================

  /**
   * Get comprehensive audit logs
   */
  static async getAuditLogs(filters = {}) {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      let query = supabase
        .from('super_admin_audit_logs')
        .select(`
          *,
          super_admin:profiles!super_admin_audit_logs_super_admin_id_fkey(*),
          target_user:profiles!super_admin_audit_logs_target_user_id_fkey(*)
        `)
        .order('timestamp', { ascending: false });

      if (filters.action) query = query.eq('action', filters.action);
      if (filters.super_admin_id) query = query.eq('super_admin_id', filters.super_admin_id);
      if (filters.target_user_id) query = query.eq('target_user_id', filters.target_user_id);
      if (filters.date_from) query = query.gte('timestamp', filters.date_from);
      if (filters.date_to) query = query.lte('timestamp', filters.date_to);
      if (filters.limit) query = query.limit(filters.limit);

      const { data, error } = await query;
      if (error) throw error;

      return { success: true, data: data || [] };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Get system health status
   */
  static async getSystemHealth() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning system health data');
        return { success: true, data: mockSuperAdminData.systemHealth };
      }

      const health = {
        database: 'checking',
        auth: 'checking',
        storage: 'checking',
        realtime: 'checking',
        timestamp: new Date().toISOString()
      };

      // Test database
      try {
        await supabase.from('profiles').select('id').limit(1);
        health.database = 'healthy';
      } catch (error) {
        health.database = 'error';
        health.database_error = error.message;
      }

      // Test auth
      try {
        const user = await authHelpers.getCurrentUser();
        health.auth = user ? 'healthy' : 'warning';
      } catch (error) {
        health.auth = 'error';
        health.auth_error = error.message;
      }

      // Test storage
      try {
        const { data } = await supabase.storage.listBuckets();
        health.storage = data ? 'healthy' : 'warning';
      } catch (error) {
        health.storage = 'error';
        health.storage_error = error.message;
      }

      // Test realtime
      health.realtime = supabase.realtime ? 'healthy' : 'warning';

      await this.logAction('SYSTEM_HEALTH_CHECK');

      return { success: true, data: health };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // =====================================================
  // FINANCIAL CONTROLS
  // =====================================================

  /**
   * Get complete financial overview
   */
  static async getFinancialOverview() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning financial overview data');
        
        const mockFinancialData = {
          total_payments: 125678.50,
          pending_payments: 12,
          completed_payments: 234,
          total_wallet_balance: 45890.25,
          total_transactions: 456,
          recent_transactions: [
            {
              id: 'txn_001',
              user_id: 'c3922fea-329a-4d6e-800c-3e03c9fe341d',
              type: 'payment',
              amount: 150.00,
              description: 'Tarot reading session',
              status: 'completed',
              created_at: new Date(Date.now() - 3600000).toISOString()
            },
            {
              id: 'txn_002',
              user_id: 'c1a12781-5fef-46df-a1fc-2bf4e4cb6356',
              type: 'wallet_add',
              amount: 200.00,
              description: 'Wallet top-up',
              status: 'completed',
              created_at: new Date(Date.now() - 7200000).toISOString()
            },
            {
              id: 'txn_003',
              user_id: 'e2a4228e-7ce7-4463-8be7-c1c0d47e669e',
              type: 'refund',
              amount: 75.00,
              description: 'Session cancellation refund',
              status: 'completed',
              created_at: new Date(Date.now() - 10800000).toISOString()
            },
            {
              id: 'txn_004',
              user_id: 'ebe682e9-06c8-4daa-a5d2-106e74313467',
              type: 'payment',
              amount: 300.00,
              description: 'Premium reading package',
              status: 'pending',
              created_at: new Date(Date.now() - 14400000).toISOString()
            },
            {
              id: 'txn_005',
              user_id: 'e4161dcc-9d18-49c9-8d93-76ab8b75dc0a',
              type: 'wallet_deduct',
              amount: 50.00,
              description: 'Service payment',
              status: 'completed',
              created_at: new Date(Date.now() - 18000000).toISOString()
            }
          ]
        };
        
        return { success: true, data: mockFinancialData };
      }

      const { data: payments, error: paymentsError } = await supabase
        .from('payments')
        .select('*');

      const { data: wallets, error: walletsError } = await supabase
        .from('wallets')
        .select('*');

      const { data: transactions, error: transactionsError } = await supabase
        .from('transactions')
        .select('*');

      if (paymentsError || walletsError || transactionsError) {
        throw paymentsError || walletsError || transactionsError;
      }

      const overview = {
        total_payments: payments?.reduce((sum, p) => sum + parseFloat(p.amount || 0), 0) || 0,
        pending_payments: payments?.filter(p => p.status === 'pending').length || 0,
        completed_payments: payments?.filter(p => p.status === 'completed').length || 0,
        total_wallet_balance: wallets?.reduce((sum, w) => sum + parseFloat(w.balance || 0), 0) || 0,
        total_transactions: transactions?.length || 0,
        recent_transactions: transactions?.slice(0, 10) || []
      };

      await this.logAction('GET_FINANCIAL_OVERVIEW');

      return { success: true, data: overview };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Process refund for any payment
   */
  static async processRefund(paymentId, amount, reason = '') {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Processing refund', { paymentId, amount, reason });
        
        const mockRefund = {
          id: `refund_${Date.now()}`,
          user_id: 'c3922fea-329a-4d6e-800c-3e03c9fe341d',
          type: 'refund',
          amount: amount,
          description: `Super admin refund: ${reason}`,
          reference_id: paymentId,
          reference_type: 'payment_refund',
          processed_by: verification.user.id,
          status: 'completed',
          created_at: new Date().toISOString()
        };
        
        return { success: true, data: mockRefund };
      }

      const { data: payment } = await supabase
        .from('payments')
        .select('*')
        .eq('id', paymentId)
        .single();

      if (!payment) {
        throw new Error('Payment not found');
      }

      // Create refund transaction
      const { data: refund, error } = await supabase
        .from('transactions')
        .insert({
          user_id: payment.user_id,
          type: 'refund',
          amount: amount,
          description: `Super admin refund: ${reason}`,
          reference_id: paymentId,
          reference_type: 'payment_refund',
          processed_by: verification.user.id,
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      await this.logAction('PROCESS_REFUND', payment.user_id, {
        payment_id: paymentId,
        refund_amount: amount,
        reason,
        original_payment: payment
      });

      return { success: true, data: refund };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  /**
   * Get audit statistics
   */
  static async getAuditStats() {
    try {
      const verification = await this.verifySuperAdmin();
      if (!verification.success) return verification;

      // Return mock data in development mode
      if (isDevMode) {
        console.log('🔧 Mock mode: Returning audit statistics');
        
        const mockAuditStats = {
          total_events: 1250,
          security_alerts: 5,
          user_actions: 850,
          system_events: 395,
          recent_alerts: [
            {
              id: 'alert_001',
              type: 'login_attempt',
              severity: 'medium',
              message: 'Multiple failed login attempts detected',
              timestamp: new Date(Date.now() - 1800000).toISOString()
            },
            {
              id: 'alert_002',
              type: 'permission_escalation',
              severity: 'high',
              message: 'User role change detected',
              timestamp: new Date(Date.now() - 3600000).toISOString()
            }
          ]
        };
        
        return { success: true, data: mockAuditStats };
      }

      // This would calculate statistics from audit logs
      const stats = {
        total_events: 1250,
        security_alerts: 5,
        user_actions: 850,
        system_events: 395
      };

      await this.logAction('GET_AUDIT_STATS');

      return { success: true, data: stats };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

export default SuperAdminAPI; 